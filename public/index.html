<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0; }
.sidebar {
  height: 100%;
  width: 0;
  position: fixed;
  z-index: 1004;
  top: 0;
  left: 0;
  background-color: rgba(0,0,0, 0.0);
  overflow-x: hidden;
  transition: 0.5s;
  box-sizing: border-box;
  border: 1px;
  border-color: #FFFFFF;
  padding-top: 100px;
}

.sidebar a {
  padding: 8px 8px 8px 32px;
  text-decoration: none;
  font-size: 25px;
  color: #FFFFFF;
  display: block;
  transition: 0.3s;
}

.sidebar a:hover {
  color: #f1f1f1;
}

.sidebar .closebtn {
  position: absolute;
  top: 0;
  left: 0px;
  font-size: 36px;
  margin-right: 30px;
  z-index: 1005;
  color: #000000;
}

.openbtn {
  top: 5px;
  left: 5px;
  position: absolute;
  font-size: 50px;
  height: 70px;
  cursor: pointer;
  background-color: #000000;
  color: #8F8F8F8F;
  padding: 10px 15px;
  border: none;
}

.openbtn:hover {
  background-color: #000000;
  color: #FFFFFF;
}

#main {
  transition: margin-left .5s;
  padding: 0px;
}


.vertical-button-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  height: calc(100% - 40px);
  padding: 10px 0;
  border-top: 1px solid rgba(255, 255, 255, 0.02);
}

.vertical-button-container button {

  display: flex;
  width: 100%;
  aspect-ratio: 1/1;
  height: 70px;
  padding: 15px 15px;
  /*background-color: rgba(255, 255, 255, 0.02);
*/
  background-color: rgba(255, 255, 255, 0.05);
  border-top: 1px solid rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #8A8A8A;
  cursor: pointer;


}

.vertical-button-container button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}


/* On smaller screens, where height is less than 450px, change the style of the sidenav (less padding and a smaller font size) */
@media screen and (max-height: 1000px) {
  .sidebar {padding-top: 100px;}
  .sidebar a {font-size: 18px;}
}


.floating-widget {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  height: 600px;
  max-width: 420px;
  min-width: 420px;
  background-color: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 0px;
  z-index: 1000;
  resize: both;
  overflow: hidden;
}

.widget-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: rgba(255, 255, 255, 0.01);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  cursor: move;
}

.widget-title {
  color: #ffffff;
}

.widget-resize {
  width: 10px;
  height: 10px;
  background-color: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: se-resize;
}

.widget-content {
  display: flex;
  flex-direction: column;
  height: calc(100% - 40px);
  overflow-y: auto;
}

.chat-container {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  background-color: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.chat-window {
  display: grid;
  padding: 0px;
  overflow-y: auto;
  min-height:600px
  max-height: calc(100% - 60px);
}

.search-bar {
  padding: 0px;
  background-color: rgba(255, 255, 255, 0.05);
  border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.search-bar input {
  width: 100%;
  height: 40px;
  padding: 5px;
  background-color: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #ffffff;
  box-sizing: border-box;
}



.button-container {
  display: flex;
  justify-content: space-between;
  padding: 0px;
  background-color: rgba(255, 255, 255, 0.05);
  border-top: 1px solid rgba(255, 255, 255, 0.02);
}

.button-container button {
  display: flex;
  width: 70px;
  aspect-ratio: 1/1;
  height: 70px;
  background-color: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #8A8A8A;
  cursor: pointer;
}

.button-container button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #ffffff;
  cursor: pointer;
}

.graph-list-container {
  position: absolute;
  top: 40px;
  left: 0px;
  width: 100%;
  height: calc(87% - 60px);
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: #ffffff;
  overflow-y: auto;
  display: none;
  z-index: 1001;
}

    #graph-list div {
      padding: 5px;
      margin-bottom: 5px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 0px;
      cursor: pointer;
    }

    #graph-list div:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    #graph-list div.selected {
      background-color: rgba(255, 255, 255, 0.3);
    }

    .graph-list-container h3 {
      margin-top: 0;
    }

    #graph-list {
      height: calc(100% - 30px);
      overflow-y: auto;
    }

    .chat-container {
      grid-column: 2;
      grid-row: 1;
      display: flex;
      flex-direction: column;
      background-color: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }


    .message {
      margin-bottom: 10px;
      padding: 5px;
      background-color: rgba(255, 255, 255, 0.0);
      border-radius: 5px;
      color: #d1cf47;
    }
    #node-info {
      position: fixed;
      top: 20px;
      right: 40px;
      width: 22%;
      padding: 0px;
      background-color: rgba(255, 255, 255, 0.0);
      border-radius: 0px;
      display: none;
      color: #ffffff;
    }

    .graph-dragging .scene-tooltip {
      display: none !important;
    }


    .message input[type="text"] {
      background-color: rgba(255, 255, 255, 0.05);
      color: #ffffff;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

@font-face {
  font-family: 'DEC Terminal Modern';
  src: url('/fonts/decterm.ttf') format('truetype');
/*https://www.freebestfonts.com/dec-terminal-modern-font */

}



body {
  font-family: 'DEC Terminal Modern', sans-serif;
}


  </style>

  <script src="https://unpkg.com/3d-force-graph"></script>
  <script src="https://cdn.jsdelivr.net/npm/three"></script>
  <script src="https://cdn.jsdelivr.net/npm/three-spritetext"></script>
</head>
<body>
  <div id="3d-graph"></div>
  <div id="node-info"></div>

  <div id="mySidebar" class="sidebar">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()"></a>
    <div class="vertical-button-container">
      <button id="user">USER</button>
      <button id="views">VIEWS</button>
      <button id="projects">PROJ</button>
      <button id="dir">DIR</button>
      <button id="utils">UTILS</button>
      <button id="retrieve">RETR</button>
    </div>
  </div>

  <div id="main">
    <button class="openbtn" onclick="openNav()">â˜° </button>
  </div>

  <div id="floating-widget" class="floating-widget">
    <div class="widget-header">
      <div class="widget-title">CITIZENSPACE</div>
      <div class="widget-resize"></div>
    </div>
    <div class="widget-content">
      <div class="chat-container">
        <div class="chat-window">
          <!-- Chat messages will be displayed here -->
        </div>
      </div>
      <div class="search-bar">
        <form id="chat-form">
          <input type="text" id="user-input" placeholder="Enter a text description...">
        </form>
      </div>
      <div class="button-container">
        <button id="load-graph-btn">Load Graph</button>
        <button id="remove-graph-btn">Remove Graph</button>
        <button id="scene-list">Scene List</button>
        <button id="save-graph-btn">Save Graph</button>
        <button id="graph-dir-btn">Graph Directory</button>
        <button id="voice-input-btn">Voice Input</button>
      </div>
      <div class="button-container">
        <button id="find-node">Find Node</button>
        <button id="edit-node">Edit Node</button>
        <button id="add-node">Add Node</button>
        <button id="link-node">Link Node</button>
        <button id="add-property">Add Property</button>
        <button id="rem-property">Remove Property</button>
      </div>
    </div>
    <div id="graph-list-container" class="graph-list-container">
      <h5>collection</h5>
      <div id="graph-list"></div>
    </div>
  </div>

  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three/build/three.module.js" } }
  </script>
  <script type="module">
    import SpriteText from "https://unpkg.com/three-spritetext/dist/three-spritetext.mjs";
    import * as THREE from 'three';
    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';
    import { UnrealBloomPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';

    let selectedNodes = new Set();
    let selectedNode = null;

    const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
      .backgroundColor('#000003')
      .nodeColor(node => selectedNodes.has(node.id) ? 'yellow' : 'light grey') // Change color based on selection


.onNodeClick(node => {
  // Check if the node is already selected
  if (selectedNodes.has(node.id)) {
    selectedNodes.delete(node.id); // If so, deselect it
    node.sphereMaterial.color.set('light grey'); // Reset the node color
  } else {
    selectedNodes.add(node.id); // Otherwise, select it
    node.sphereMaterial.color.set('yellow'); // Set the selected node color
  }

  Graph.refresh(); // Refresh the graph to update the visuals
  displayNodeInfo(node); // Continue with displaying node info
})


      .showNavInfo(false)
      .nodeLabel('id')
      .nodeAutoColorBy('group')


.nodeThreeObject(node => {
  const sphereGeometry = new THREE.SphereGeometry(10);
  const sphereMaterial = new THREE.MeshBasicMaterial({
    color: 'light grey',
    transparent: true,
    opacity: 0.4
  });
  const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
  const sprite = new SpriteText(node.label); // Use node.label instead of node.id
  sprite.textHeight = 8;
  sprite.color = node.color || 'grey';
  const container = new THREE.Object3D();
  container.add(sphereMesh);
  container.add(sprite);
  sprite.position.set(0, 0, sphereGeometry.parameters.radius + 20);

  // Store the material reference in the node's data object
  node.sphereMaterial = sphereMaterial;

  return container;
})


      .linkThreeObjectExtend(true)
      .linkThreeObject(link => {
        const sprite = new SpriteText(`${link.source} > ${link.target}`);
        sprite.color = 'lightgrey';
        sprite.textHeight = 3;
        return sprite;
      })
      .linkPositionUpdate((sprite, { start, end }) => {
        const middlePos = Object.assign(...['x', 'y', 'z'].map(c => ({
          [c]: start[c] + (end[c] - start[c]) / 3
        })));
        Object.assign(sprite.position, middlePos);
      });

    let simulation;

    function initializeForceSimulation(graphData) {
      if (simulation) {
        simulation.stop();
      }

    simulation = d3.forceSimulation()
      .force('charge', d3.forceManyBody().strength(-100)) // Adjust the strength
      .force('link', d3.forceLink().id(d => d.id).distance(150).strength(0.1)) // Adjust the distance and strength
      .force('center', d3.forceCenter())
      .alphaDecay(0.01) // Adjust the alphaDecay
      .velocityDecay(0.5); // Adjust the velocityDecay

      simulation.nodes(graphData.nodes);
      simulation.force('link').links(graphData.links);

      simulation.on('tick', () => {
        Graph.graphData({
          nodes: graphData.nodes.map(node => ({ ...node })),
          links: graphData.links.map(link => ({ ...link }))
        });
      });
    }

    function displayNodeInfo(node) {
      const chatWindow = document.querySelector('.chat-window');
      const nodeInfoElement = document.createElement('div');
      nodeInfoElement.className = 'message';
      nodeInfoElement.innerHTML = `
        <strong>Node Information:</strong><br>
        ID: ${node.id}<br>
        Label: ${node.label || 'N/A'}<br>
        Color: ${node.color}<br>
        Shape: ${node.shape || 'Sphere'}<br>
        UUID: ${node.uuid || 'N/A'}<br>
        Date: ${node.date || 'N/A'}<br>
        Source: ${node.source || 'N/A'}<br>
        URL: ${node.url ? `<a href="${node.url}" target="_blank">${node.url}</a>` : 'N/A'}<br>
      `;
      chatWindow.appendChild(nodeInfoElement);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    let selectedNode1 = null;
    let selectedNode2 = null;

    Graph.onNodeClick(node => {
      document.getElementById('3d-graph').classList.remove('graph-dragging');
      selectedNode = node;
      displayNodeInfo(node);

      // Remove existing edit node element from the chat window
      const existingEditNodeElement = document.querySelector('.message.edit-node');
      if (existingEditNodeElement) {
        existingEditNodeElement.remove();
      }

      if (!selectedNode1) {
        selectedNode1 = node;
        console.log('Selected first node:', node);
      } else if (!selectedNode2 && node !== selectedNode1) {
        selectedNode2 = node;
        console.log('Selected second node:', node);
        createLinkBetweenNodes();
        // Reset the selected nodes
        selectedNode1 = null;
        selectedNode2 = null;
      } else {
        // Reset the selected nodes if the same node is clicked again
        selectedNode1 = null;
        selectedNode2 = null;
      }
    });

async function updateNodeProperties(nodeUuid) {
  const currentGraphData = Graph.graphData();
  const node = currentGraphData.nodes.find(node => node.uuid === nodeUuid);

  if (node) {
    node.id = document.getElementById('node-id').value;
    node.label = document.getElementById('node-label').value;
    node.color = document.getElementById('node-color').value;
    node.shape = document.getElementById('node-shape').value;
    node.uuid = document.getElementById('node-uuid').value;
    node.date = document.getElementById('node-date').value;
    node.source = document.getElementById('node-source').value;
    node.url = document.getElementById('node-url').value;

    // Update the node label in the graph visualization
    const nodeObject = Graph.scene().getObjectByName(node.uuid);
    if (nodeObject) {
      const sprite = nodeObject.children.find(child => child instanceof SpriteText);
      if (sprite) {
        sprite.text = node.label;
      }
    }

    Graph.graphData(currentGraphData);
    Graph.nodeThreeObject(nodeObject => {
      const sprite = nodeObject.children.find(child => child instanceof SpriteText);
      if (sprite) {
        sprite.text = nodeObject.__data.label;
      }
    });

    // Save the updated graph data
    await saveGraphData(currentGraphData);
  }
}


    // Global variable to store loaded graphs
    let loadedGraphs = [];

    async function loadGraph(graphFileName) {
      return new Promise((resolve, reject) => {
        Graph.jsonUrl(`graphs/${graphFileName}`, resolve, reject);
      });
    }

    // Function to add a graph to the loaded graphs list and update the scene view
    async function addGraphToList(graphFileName) {
      const graphData = await loadGraph(graphFileName);
      loadedGraphs.push(graphData);
      updateSceneView();
      updateGraphVisualization(graphData, 'add');
    }

    // Function to remove a graph from the loaded graphs list and update the scene view
    function removeGraphFromList(graphIndex) {
      const graphData = loadedGraphs[graphIndex];
      loadedGraphs.splice(graphIndex, 1);
      updateSceneView();
      updateGraphVisualization(graphData, 'remove');
    }

    // Update the displayGraphList function to load the selected graph

async function displayGraphList() {
  try {
    const response = await fetch('/api/graphs');
    if (response.ok) {
      const data = await response.json();
      const graphList = document.getElementById('graph-list');
      graphList.innerHTML = '';
      data.forEach(graph => {
        const graphItem = document.createElement('div');
        graphItem.textContent = graph;
        graphItem.addEventListener('click', async () => {
          const graphData = await loadGraph(graph);
          addGraphToScene(graphData);
        });
        graphList.appendChild(graphItem);
      });
    } else {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

    async function addGraphToScene(graphData) {
      try {
        const response = await fetch('scene.json');
        if (response.ok) {
          const sceneData = await response.json();
          sceneData.graphs.push(graphData);
          await updateSceneData(sceneData);
          updateGraphVisualization();
        } else {
          console.error('Error:', response.status);
        }
      } catch (error) {
        console.error('Error:', error);
      }
    }

    async function updateSceneData(sceneData) {
      try {
        const response = await fetch('scene.json', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(sceneData)
        });
        if (!response.ok) {
          throw new Error('Failed to update scene data');
        }
      } catch (error) {
        console.error('Error updating scene data:', error);
      }
    }

    function updateGraphVisualization() {
      fetch('scene.json')
        .then(response => response.json())
        .then(sceneData => {
          const combinedGraphData = sceneData.graphs.reduce((acc, graphData) => {
            acc.nodes = [...acc.nodes, ...graphData.nodes];
            acc.links = [...acc.links, ...graphData.links];
            return acc;
          }, { nodes: [], links: [] });
          Graph.graphData(combinedGraphData);
          initializeForceSimulation(combinedGraphData);
        })
        .catch(error => {
          console.error('Error:', error);
        });
    }

    const loadGraphBtn = document.getElementById('load-graph-btn');

    loadGraphBtn.addEventListener('click', async () => {
      try {
        const response = await fetch('/api/graphs');
        if (response.ok) {
          const graphFiles = await response.json();
          if (graphFiles.length > 0) {
            const latestFile = graphFiles[0]; // Get the latest file (assuming the list is sorted in descending order)
            Graph.jsonUrl(`graphs/${latestFile}`);
          } else {
            console.log('No graph files found.');
          }
        } else {
          console.error('Error:', response.status);
        }
      } catch (error) {
        console.error('Error:', error);
      }
    });


    document.addEventListener('click', event => {
      const nodeInfo = document.getElementById('node-info');
      // Check if the click is outside the node info box by checking if the node-info element or its children are clicked
      if (nodeInfo.style.display !== 'none' && !nodeInfo.contains(event.target)) {
        nodeInfo.style.display = 'none';
      }
    });


function addNodeInView() {
  const distanceInFrontOfCamera = 100; // Adjust this value to suit the scale of your graph

  // Get the camera and controls object from the graph
  const camera = Graph.camera();
  const controls = Graph.controls();

  // Calculate the direction in which the camera is looking
  const direction = new THREE.Vector3();
  camera.getWorldDirection(direction);
  direction.normalize(); // Normalize the direction vector (convert to vector of length 1)

  // Calculate the new position
  const newPosition = direction.multiplyScalar(distanceInFrontOfCamera).add(camera.position);

  // Create a new node at this position
  const newNode = {
    id: `Node${Graph.graphData().nodes.length + 1}`,
    // Position the new node in front of the camera
    x: newPosition.x,
    y: newPosition.y,
    z: newPosition.z,
    group: Math.floor(Math.random() * 10) // Example group assignment
  };

  // Add the new node to the graph data
  const graphData = Graph.graphData();
  graphData.nodes.push(newNode);
  Graph.graphData(graphData);

  // Optionally, adjust the camera to ensure the new node is in view
  controls.target.set(newPosition.x, newPosition.y, newPosition.z);
  // This line would reorient the camera's focus to the new node's position, if desired
}

document.addEventListener('click', (event) => {
  if (!floatingWidget.contains(event.target)) {
    graphListContainer.style.display = 'none';
  }
});

const graphDirBtn = document.getElementById('graph-dir-btn');
const graphListContainer = document.getElementById('graph-list-container');
const floatingWidget = document.getElementById('floating-widget');

graphDirBtn.addEventListener('click', () => {
  graphListContainer.style.display = 'block';
  displayGraphList();
});

const widgetHeader = document.querySelector('.widget-header');

let isDragging = false;
let startX, startY, startWidth, startHeight;

widgetHeader.addEventListener('mousedown', startDragging);
document.addEventListener('mousemove', drag);
document.addEventListener('mouseup', stopDragging);
document.addEventListener('mouseleave', stopDragging);

function startDragging(e) {
  isDragging = true;
  startX = e.clientX - floatingWidget.offsetLeft;
  startY = e.clientY - floatingWidget.offsetTop;
  startWidth = floatingWidget.offsetWidth;
  startHeight = floatingWidget.offsetHeight;
}

function drag(e) {
  if (!isDragging) return;

  const currentX = e.clientX - startX;
  const currentY = e.clientY - startY;
  const currentWidth = startWidth + (e.clientX - floatingWidget.offsetLeft - startX);
  const currentHeight = startHeight + (e.clientY - floatingWidget.offsetTop - startY);

  floatingWidget.style.left = currentX + 'px';
  floatingWidget.style.top = currentY + 'px';
  floatingWidget.style.width = currentWidth + 'px';
  floatingWidget.style.height = currentHeight + 'px';
}

function stopDragging() {
  isDragging = false;
}

const graphContainer = document.getElementById('3d-graph');
graphContainer.addEventListener('dragover', dragOver);
graphContainer.addEventListener('drop', drop);

function dragStart(event) {
  event.dataTransfer.setData('text/plain', event.target.textContent);
}

function dragOver(event) {
  event.preventDefault();
}

function drop(event) {
  event.preventDefault();
  const graphName = event.dataTransfer.getData('text');

  fetch(`graphs/${graphName}`)
    .then(response => response.json())
    .then(graphData => {
      Graph.graphData(graphData);
      initializeForceSimulation(graphData);
    })
    .catch(error => {
      console.error('Error:', error);
    });
}

// Helper function to generate a unique UUID
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Helper function to get the current date in the desired format
function getCurrentDate() {
  const today = new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

const editNodeElement = document.createElement('div');
editNodeElement.className = 'message edit-node';

document.getElementById('edit-node').addEventListener('click', () => {
  if (selectedNode) {
    // ...

    editNodeElement.innerHTML = `
      <strong>Edit Node Information:</strong><br>
      ID: <input type="text" id="node-id" value="${selectedNode.id}"><br>
      Label: <input type="text" id="node-label" value="${selectedNode.label}"><br>
      Color: <input type="text" id="node-color" value="${selectedNode.color}"><br>
      Shape: <input type="text" id="node-shape" value="${selectedNode.shape}"><br>
      UUID: <input type="text" id="node-uuid" value="${selectedNode.uuid}"><br>
      Date: <input type="text" id="node-date" value="${selectedNode.date}"><br>
      Source: <input type="text" id="node-source" value="${selectedNode.source}"><br>
      URL: <input type="text" id="node-url" value="${selectedNode.url}"><br>
      <button onclick="updateNodeProperties('${selectedNode.uuid}')">Update</button>
    `;

    chatWindow.appendChild(editNodeElement);
    chatWindow.scrollTop = chatWindow.scrollHeight;

    editNodeElement.addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        updateNodeProperties(selectedNode.id);
      }
    });

    document.addEventListener('click', event => {
      if (!editNodeElement.contains(event.target)) {
        updateNodeProperties(selectedNode.id);
      }
    });
  } else {
    console.log('No node selected for editing.');
  }
});

document.getElementById('add-node').addEventListener('click', () => {
  addNodeToGraph();
});

function addNodeToGraph() {
  const currentGraphData = Graph.graphData();

  // Create a new node with default properties
  const newNode = {
    id: `Node${currentGraphData.nodes.length + 1}`,
    label: `Node${currentGraphData.nodes.length + 1}`,
    color: '#AAAAAA',
    shape: 'circle',
    uuid: generateUUID(),
    date: getCurrentDate(),
    source: 'User Input',
    url: ''
  };

  // Add the new node to the current graph data
  currentGraphData.nodes.push(newNode);

  Graph.graphData(currentGraphData);

  // Update the force simulation with the new node
  Graph.simulation.stop();
  Graph.simulation.nodes(currentGraphData.nodes);
  Graph.simulation.alpha(1).restart();
}

function createLinkBetweenNodes() {
  if (selectedNode1 && selectedNode2) {
    const currentGraphData = Graph.graphData();

    // Create a new link between the selected nodes with default properties
    const newLink = {
      source: selectedNode1.id,
      target: selectedNode2.id,
      label: 'Link',
      title: 'Link',
      arrows: 'to'
    };

    // Add the new link to the current graph data
    currentGraphData.links.push(newLink);

    Graph.graphData(currentGraphData);

    // Update the force simulation with the new link
    Graph.simulation.stop();
    Graph.simulation.force('link').links(currentGraphData.links);
    Graph.simulation.alpha(1).restart();
  }
}

async function saveGraphData(graphData) {
  try {
    const response = await fetch('/save-graph', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(graphData)
    });

    if (response.ok) {
      console.log('Graph data saved successfully');
    } else {
      console.error('Error saving graph data:', response.status);
    }
  } catch (error) {
    console.error('Error saving graph data:', error);
  }
}

// Removing Graphs
document.getElementById('remove-graph-btn').addEventListener('click', () => {
  Graph.graphData({nodes: [], links: []});
});

// Combining Graphs
document.getElementById('scene-list').addEventListener('click', async () => {
  const selectedGraphs = Array.from(document.querySelectorAll('#graph-select option:checked')).map(option => option.value);
  try {
    const combinedGraph = {nodes: [], links: []};
    for (const graph of selectedGraphs) {
      const response = await fetch(`graphs/${graph}`);
      if (response.ok) {
        const graphData = await response.json();
        combinedGraph.nodes.push(...graphData.nodes);
        combinedGraph.links.push(...graphData.links);
      }
    }
    Graph.graphData(combinedGraph);
  } catch (error) {
    console.error('Error:', error);
  }
});

// Saving Graphs
document.getElementById('save-graph-btn').addEventListener('click', async () => {
  const graphData = Graph.graphData();
  try {
    const response = await fetch('/api/save-graph', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(graphData)
    });
    if (response.ok) {
      console.log('Graph saved successfully');
    } else {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Error:', error);
  }
});

// Load graph on page load
fetch('graphs/default-graph.json')
  .then(response => response.json())
  .then(graphData => {
    Graph.graphData(graphData);
    initializeForceSimulation(graphData);
  })
  .catch(error => {
    console.error('Error:', error);
  });

async function loadLatestGraph() {
  try {
    const response = await fetch('/api/latest-graph');
    if (response.ok) {
      const data = await response.json();
      const latestFile = data.latestFile;
      const graphData = await fetch(`graphs/${latestFile}`).then(res => res.json());
      Graph.graphData(graphData);
      initializeForceSimulation(graphData);
    } else if (response.status !== 404) {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

let isRecording = false;

document.addEventListener('keydown', async (event) => {
  if (event.code === 'Space' && isRecording) {
    isRecording = false;
    try {
      const response = await fetch('http://localhost:5000/stop_recording', { method: 'POST' });
      if (response.ok) {
        const data = await response.json();
        displayMessage('>', data.response);
        await displayGraphList();
      } else {
        console.error('Error:', response.status);
        displayMessage('>', 'An error occurred. Please check the server logs.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('>', 'An error occurred. Please check the browser console.');
    }
  }
});

document.getElementById('voice-input-btn').addEventListener('click', async () => {
  if (!isRecording) {
    isRecording = true;
    try {
      const startResponse = await fetch('http://localhost:5000/start_recording', { method: 'POST' });
      if (startResponse.ok) {
        const startData = await startResponse.json();
        displayMessage('>', 'Recording started.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('>', 'An error occurred. Please check the browser console.');
    }
  } else {
    isRecording = false;
    try {
      const stopResponse = await fetch('http://localhost:5000/stop_recording', { method: 'POST' });
      if (stopResponse.ok) {
        const stopData = await stopResponse.json();
        displayMessage('>', stopData.log);
        displayMessage('>', stopData.response);
        await displayGraphList();

        // Load the latest graph
        const graphResponse = await fetch('/api/graphs');
        if (graphResponse.ok) {
          const graphFiles = await graphResponse.json();
          if (graphFiles.length > 0) {
            const latestFile = graphFiles[0];
            Graph.jsonUrl(`graphs/${latestFile}`);
          }
        }
      } else {
        console.error('Error:', stopResponse.status);
        displayMessage('>', 'An error occurred. Please check the server logs.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('>', 'An error occurred. Please check the browser console.');
    }
  }
});

const chatForm = document.getElementById('chat-form');
const userInput = document.getElementById('user-input');
const chatWindow = document.querySelector('.chat-window');

chatForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const message = userInput.value.trim();
  if (message !== '') {
    displayMessage('user', message);
    userInput.value = '';
    try {
      const response = await fetch('http://localhost:5000/process', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message })
      });

      if (response.ok) {
        const data = await response.json();
        displayMessage('>', data.response);
        await displayGraphList();

        // Load the latest graph
        const graphResponse = await fetch('/api/graphs');
        if (graphResponse.ok) {
          const graphFiles = await graphResponse.json();
          if (graphFiles.length > 0) {
            const latestFile = graphFiles[0];
            Graph.jsonUrl(`graphs/${latestFile}`);
          }
        }
      } else {
        console.error('Error:', response.status);
        displayMessage('>', 'An error occurred. Please check the server logs.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('>', 'An error occurred. Please check the browser console.');
    }
  }
});

function displayMessage(sender, message) {
  const messageElement = document.createElement('div');
  messageElement.className = 'message';
  messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
  chatWindow.appendChild(messageElement);
  chatWindow.scrollTop = chatWindow.scrollHeight;
}


// Call the displayGraphList function to populate the graph list
displayGraphList();



 </script>

 <script>
   function openNav() {
     document.getElementById("mySidebar").style.width = "70px";
     document.getElementById("main").style.marginLeft = "70px";
   }

   function closeNav() {
     document.getElementById("mySidebar").style.width = "0";
     document.getElementById("main").style.marginLeft = "0";
   }

   // Close the sidebar when clicking outside of it
   document.addEventListener("click", function(event) {
     var sidebar = document.getElementById("mySidebar");
     var openBtn = document.querySelector(".openbtn");
     if (!sidebar.contains(event.target) && event.target !== openBtn) {
       closeNav();
     }
   });

  displayGraphList();
  <script> function openNav() { document.getElementById("mySidebar").style.width = "70px"; document.getElementById("main").style.marginLeft = "70px"; } function closeNav() { document.getElementById("mySidebar").style.width = "0"; document.getElementById("main").style.marginLeft = "0"; } // Close the sidebar when clicking outside of it document.addEventListener("click", function(event) { var sidebar = document.getElementById("mySidebar"); var openBtn = document.querySelector(".openbtn"); if (!sidebar.contains(event.target) && event.target !== openBtn) { closeNav(); } }); </script>
 </body>
</html>

