<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0; }



.floating-widget {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  max-width: 503px;
  min-width: 503px;
  height: 600px;
  background-color: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 0px;
  z-index: 1000;
  resize: both;
  overflow: hidden;
}

.widget-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: rgba(255, 255, 255, 0.01);
  border-bottom: 1px solid rgba(255, 255, 255, 0.2);
  cursor: move;
}

.widget-title {
  color: #ffffff;
}

.widget-resize {
  width: 10px;
  height: 10px;
  background-color: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: se-resize;
}

.widget-content {
  display: flex;
  flex-direction: column;
  height: calc(100% - 40px);
  overflow-y: auto;
}

.chat-container {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  background-color: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.chat-window {
  display: grid;
  padding: 0px;
  overflow-y: auto;
  min-height:600px
  max-height: calc(100% - 60px);
}

.search-bar {
  padding: 0px;
  background-color: rgba(255, 255, 255, 0.05);
  border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.search-bar input {
  width: 100%;
  height: 40px;
  padding: 5px;
  background-color: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #ffffff;
  box-sizing: border-box;
}

.button-container {
  display: flex;
  height: 70px;
  justify-content: space-between;
  padding: 0px;
  background-color: rgba(255, 255, 255, 0.05);
  border-top: 1px solid rgba(255, 255, 255, 0.02);
}

.button-container button {
  display: flex;
  width: 100%;
  aspect-ratio: 1/1;
  height: 100%;
  padding: 10px 10px;
  background-color: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #8A8A8A;
  cursor: pointer;
}

.button-container button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #ffffff;
  cursor: pointer;
}

.graph-list-container {
  position: absolute;
  top: 40px;
  left: 0px;
  width: 100%;
  height: calc(87% - 60px);
  padding: 10px;
  background-color: rgba(0, 0, 0, 0.8);
  color: #ffffff;
  overflow-y: auto;
  display: none;
  z-index: 1001;
}


    #graph-list div {
      padding: 5px;
      margin-bottom: 5px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 0px;
      cursor: pointer;
    }

    #graph-list div:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    #graph-list div.selected {
      background-color: rgba(255, 255, 255, 0.3);
    }

    .graph-list-container h3 {
      margin-top: 0;
    }

    #graph-list {
      height: calc(100% - 30px);
      overflow-y: auto;
    }



    .chat-container {
      grid-column: 2;
      grid-row: 1;
      display: flex;
      flex-direction: column;
      background-color: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }


    .message {
      margin-bottom: 10px;
      padding: 5px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      color: #ffffff;
    }
    #node-info {
      position: fixed;
      top: 20px;
      right: 40px;
      width: 22%;
      padding: 0px;
      background-color: rgba(255, 255, 255, 0.0);
      border-radius: 0px;
      display: none;
      color: #ffffff;
    }


@font-face {
  font-family: 'DEC Terminal Modern';
  src: url('/fonts/decterm.ttf') format('truetype');
/*https://www.freebestfonts.com/dec-terminal-modern-font */

}



body {
  font-family: 'DEC Terminal Modern', sans-serif;
}


    </style>
    <script src="https://unpkg.com/3d-force-graph"></script>
    <script src="https://cdn.jsdelivr.net/npm/three"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext"></script>
    </head>

    <body>
    <div id="3d-graph"></div>
    <div id="node-info"></div>

    <div id="floating-widget" class="floating-widget">
      <div class="widget-header">
        <div class="widget-title">CITIZENSPACE</div>
        <div class="widget-resize"></div>
      </div>
      <div class="widget-content">
        <div class="chat-container">
          <div class="chat-window">
            <!-- Chat messages will be displayed here -->
          </div>


        </div>

          <div class="search-bar">
            <form id="chat-form">
              <input type="text" id="user-input" placeholder="Enter a text description...">
            </form>
          </div>


        <div class="button-container">
          <button id="load-graph-btn">Load Graph</button>
          <button id="remove-graph-btn">Remove Graph</button>
          <button id="scene-list">Scene List</button>
          <button id="save-graph-btn">Save Graph</button>
          <button id="graph-dir-btn">Graph Directory</button>
          <button id="voice-input-btn">Voice Input</button>
        </div>

        <div class="button-container">
          <button id="find-node">Find Node</button>
          <button id="edit-node">Edit Node</button>
          <button id="add-node">Add Node</button>
          <button id="link-node">Link Node</button>
          <button id="add-property">Add Property</button>
          <button id="rem-property">Remove Property</button>
        </div>

      </div>
      <div id="graph-list-container" class="graph-list-container">
        <h5>collection</h5>
        <div id="graph-list"></div>
      </div>
    </div>



  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three/build/three.module.js" } }
  </script>
  <script type="module">
    import SpriteText from "https://unpkg.com/three-spritetext/dist/three-spritetext.mjs";
    import * as THREE from 'three';

    import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';
    import { UnrealBloomPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';


    const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
      //.jsonUrl('graph.json')
      //.jsonUrl('graphs/chatgpt_graph_20240321_062405.json') // Add this line here

      .backgroundColor('#000003')
      .onNodeClick(node => {
        displayNodeInfo(node);
      })
      .showNavInfo(false)

      .nodeLabel('id')
      .nodeAutoColorBy('group')
      .nodeThreeObject(node => {
        const sphereGeometry = new THREE.SphereGeometry(10);
        const sphereMaterial = new THREE.MeshBasicMaterial({
          color: 'light grey',
          transparent: true,
          opacity: 0.4
        });
        const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
        const sprite = new SpriteText(node.id);
        sprite.textHeight = 8;
        sprite.color = node.color || 'grey';
        const container = new THREE.Object3D();
        container.add(sphereMesh);
        container.add(sprite);

        // Set the position of the sprite text to be in front of the sphere mesh
        sprite.position.set(0, 0, sphereGeometry.parameters.radius + 20);

        return container;
      })
      .linkThreeObjectExtend(true)
      .linkThreeObject(link => {
        const sprite = new SpriteText(`${link.source} > ${link.target}`);
        sprite.color = 'lightgrey';
        sprite.textHeight = 3;
        return sprite;
      })
      .linkPositionUpdate((sprite, { start, end }) => {
        const middlePos = Object.assign(...['x', 'y', 'z'].map(c => ({
          [c]: start[c] + (end[c] - start[c]) / 3
        })));
        Object.assign(sprite.position, middlePos);
      });



    let simulation;

function initializeForceSimulation(graphData) {
  if (simulation) {
    simulation.stop();
  }

  simulation = d3.forceSimulation()
    .force('charge', d3.forceManyBody().strength(-200)) // Decreased repulsion strength
    .force('link', d3.forceLink().id(d => d.id).distance(100).strength(1)) // Increased link distance and strength
    .force('center', d3.forceCenter())
    .alphaDecay(0.05) // Increased alphaDecay for faster convergence
    .velocityDecay(0.8); // Decreased velocityDecay to maintain node velocities

  simulation.nodes(graphData.nodes);
  simulation.force('link').links(graphData.links);

  simulation.on('tick', () => {
    Graph.graphData({
      nodes: graphData.nodes.map(node => ({ ...node })),
      links: graphData.links.map(link => ({ ...link }))
    });
  });
}

    Graph.onNodeClick(node => {
      const nodeInfo = document.getElementById('node-info');
      nodeInfo.innerHTML = `
        <strong>Node Information:</strong><br>
        ID: ${node.id}<br>
        Label: ${node.label || 'N/A'}<br>
        Color: ${node.color}<br>
        Shape: ${node.shape || 'Sphere'}<br>
        UUID: ${node.uuid || 'N/A'}<br>
        Date: ${node.date || 'N/A'}<br>
        Source: ${node.source || 'N/A'}<br>
        URL: ${node.url ? `<a href="${node.url}" target="_blank">${node.url}</a>` : 'N/A'}<br>
      `;
      nodeInfo.style.display = 'block';
    });





///////////////////////////// LOADING GRAPHS   ////////////////////////////////


// Global variable to store loaded graphs
let loadedGraphs = [];

// Function to load a graph
async function loadGraph(graphFileName) {
  return new Promise((resolve, reject) => {
    Graph.jsonUrl(`graphs/${graphFileName}`, resolve, reject);
  });
}


// Function to add a graph to the loaded graphs list and update the scene view
async function addGraphToList(graphFileName) {
  const graphData = await loadGraph(graphFileName);
  loadedGraphs.push(graphData);
  updateSceneView();
  updateGraphVisualization(graphData, 'add');
}

// Function to remove a graph from the loaded graphs list and update the scene view
function removeGraphFromList(graphIndex) {
  const graphData = loadedGraphs[graphIndex];
  loadedGraphs.splice(graphIndex, 1);
  updateSceneView();
  updateGraphVisualization(graphData, 'remove');
}

// Function to update the graph visualization dynamically
function updateGraphVisualization(graphData, operation) {
  const currentGraphData = Graph.graphData();

  if (operation === 'add') {
    // Add nodes and links to the existing graph data
    currentGraphData.nodes = currentGraphData.nodes.concat(graphData.nodes);
    currentGraphData.links = currentGraphData.links.concat(graphData.links);
  } else if (operation === 'remove') {
    // Remove nodes and links from the existing graph data
    currentGraphData.nodes = currentGraphData.nodes.filter(node => !graphData.nodes.includes(node));
    currentGraphData.links = currentGraphData.links.filter(link => !graphData.links.includes(link));
  }

  Graph.graphData(currentGraphData);
  Graph.simulation.restart();
}

// Update the displayGraphList function to load the selected graph
async function displayGraphList() {
  try {
    const response = await fetch('/api/graphs');
    if (response.ok) {
      const data = await response.json();
      const graphList = document.getElementById('graph-list');
      graphList.innerHTML = '';
      data.forEach(graph => {
        const graphItem = document.createElement('div');
        graphItem.textContent = graph;
        graphItem.addEventListener('click', async () => {
          graphItem.classList.add('selected');
          const graphData = await loadGraph(graph);
          if (graphData) {
            addGraphToList(graphData);
            updateGraphVisualization();
          }
        });
        graphList.appendChild(graphItem);
      });
      return data[0];
    } else {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}


//////////////////////////////////////////////////////////////////




const loadGraphBtn = document.getElementById('load-graph-btn');

loadGraphBtn.addEventListener('click', async () => {
  try {
    const response = await fetch('/api/graphs');
    if (response.ok) {
      const graphFiles = await response.json();
      if (graphFiles.length > 0) {
        const latestFile = graphFiles[0]; // Get the latest file (assuming the list is sorted in descending order)
        Graph.jsonUrl(`graphs/${latestFile}`);
      } else {
        console.log('No graph files found.');
      }
    } else {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Error:', error);
  }
});

    document.addEventListener('click', event => {
      const nodeInfo = document.getElementById('node-info');
      // Check if the click is outside the node info box by checking if the node-info element or its children are clicked
      if (nodeInfo.style.display !== 'none' && !nodeInfo.contains(event.target)) {
        nodeInfo.style.display = 'none';
      }
    });

    function addNode(node) {
      const graphData = Graph.graphData();
      graphData.nodes.push(node);
      Graph.graphData(graphData);
      initializeForceSimulation(graphData);
    }

    function addNodeInView() {
      const distanceInFrontOfCamera = 100; // Adjust this value to suit the scale of your graph

      // Get the camera and controls object from the graph
      const camera = Graph.camera();
      const controls = Graph.controls();

      // Calculate the direction in which the camera is looking
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      direction.normalize(); // Normalize the direction vector (convert to vector of length 1)

      // Calculate the new position
      const newPosition = direction.multiplyScalar(distanceInFrontOfCamera).add(camera.position);

      // Create a new node at this position
      const newNode = {
        id: `Node${Graph.graphData().nodes.length + 1}`,
        // Position the new node in front of the camera
        x: newPosition.x,
        y: newPosition.y,
        z: newPosition.z,
        group: Math.floor(Math.random() * 10) // Example group assignment

      };

      // Add the new node to the graph data
      const graphData = Graph.graphData();
      graphData.nodes.push(newNode);
      Graph.graphData(graphData);

      // Optionally, adjust the camera to ensure the new node is in view
      controls.target.set(newPosition.x, newPosition.y, newPosition.z);
      // This line would reorient the camera's focus to the new node's position, if desired
    }

    document.addEventListener('click', (event) => {
  if (!floatingWidget.contains(event.target)) {
    graphListContainer.style.display = 'none';
  }
});



    const graphDirBtn = document.getElementById('graph-dir-btn');
    const graphListContainer = document.getElementById('graph-list-container');
    const floatingWidget = document.getElementById('floating-widget');


    graphDirBtn.addEventListener('click', () => {
      graphListContainer.style.display = 'block';
      displayGraphList();
    });

    const widgetHeader = document.querySelector('.widget-header');

    let isDragging = false;
    let startX, startY, startWidth, startHeight;

    widgetHeader.addEventListener('mousedown', startDragging);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDragging);
    document.addEventListener('mouseleave', stopDragging);

    function startDragging(e) {
      isDragging = true;
      startX = e.clientX - floatingWidget.offsetLeft;
      startY = e.clientY - floatingWidget.offsetTop;
      startWidth = floatingWidget.offsetWidth;
      startHeight = floatingWidget.offsetHeight;
    }

    function drag(e) {
      if (!isDragging) return;

      const currentX = e.clientX - startX;
      const currentY = e.clientY - startY;
      const currentWidth = startWidth + (e.clientX - floatingWidget.offsetLeft - startX);
      const currentHeight = startHeight + (e.clientY - floatingWidget.offsetTop - startY);

      floatingWidget.style.left = currentX + 'px';
      floatingWidget.style.top = currentY + 'px';
      floatingWidget.style.width = currentWidth + 'px';
      floatingWidget.style.height = currentHeight + 'px';
    }

    function stopDragging() {
      isDragging = false;
    }




    const graphContainer = document.getElementById('3d-graph');
    graphContainer.addEventListener('dragover', dragOver);
    graphContainer.addEventListener('drop', drop);

    function dragStart(event) {
      event.dataTransfer.setData('text/plain', event.target.textContent);
    }

    function dragOver(event) {
      event.preventDefault();
    }

    function drop(event) {
      event.preventDefault();
      const graphName = event.dataTransfer.getData('text');

      fetch(`graphs/${graphName}`)
        .then(response => response.json())
        .then(graphData => {
          Graph.graphData(graphData);
          initializeForceSimulation(graphData);
        })
        .catch(error => {
          console.error('Error:', error);
        });
    }


    document.getElementById('load-graph-btn').addEventListener('click', () => {
      const selectedGraph = document.getElementById('graph-select').value;
      Graph.jsonUrl(`graphs/${selectedGraph}`);
    });

    // Removing Graphs
    document.getElementById('remove-graph-btn').addEventListener('click', () => {
      Graph.graphData({nodes: [], links: []});
    });



    // Combining Graphs
    document.getElementById('scene-list').addEventListener('click', async () => {
      const selectedGraphs = Array.from(document.querySelectorAll('#graph-select option:checked')).map(option => option.value);
      try {
        const combinedGraph = {nodes: [], links: []};
        for (const graph of selectedGraphs) {
          const response = await fetch(`graphs/${graph}`);
          if (response.ok) {
            const graphData = await response.json();
            combinedGraph.nodes.push(...graphData.nodes);
            combinedGraph.links.push(...graphData.links);
          }
        }
        Graph.graphData(combinedGraph);
      } catch (error) {
        console.error('Error:', error);
      }
    });

    // Saving Graphs
    document.getElementById('save-graph-btn').addEventListener('click', async () => {
      const graphData = Graph.graphData();
      try {
        const response = await fetch('/api/save-graph', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(graphData)
        });
        if (response.ok) {
          console.log('Graph saved successfully');
        } else {
          console.error('Error:', response.status);
        }
      } catch (error) {
        console.error('Error:', error);
      }
    });

// Load graph on page load
fetch('graphs/default-graph.json')
  .then(response => response.json())
  .then(graphData => {
    Graph.graphData(graphData);
    initializeForceSimulation(graphData);
  })
  .catch(error => {
    console.error('Error:', error);
  });

async function loadLatestGraph() {
  try {
    const response = await fetch('/api/latest-graph');
    if (response.ok) {
      const data = await response.json();
      const latestFile = data.latestFile;
      const graphData = await fetch(`graphs/${latestFile}`).then(res => res.json());
      Graph.graphData(graphData);
      initializeForceSimulation(graphData);
    } else if (response.status !== 404) {
      console.error('Error:', response.status);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}



////////////////////VOICE RECORDING//////////////////////


let isRecording = false;

document.addEventListener('keydown', async (event) => {
  if (event.code === 'Space' && isRecording) {
    isRecording = false;
    try {
      const response = await fetch('http://localhost:5000/stop_recording', { method: 'POST' });
      if (response.ok) {
        const data = await response.json();
        displayMessage('assistant', data.response);
        await displayGraphList();
      } else {
        console.error('Error:', response.status);
        displayMessage('assistant', 'An error occurred. Please check the server logs.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('assistant', 'An error occurred. Please check the browser console.');
    }
  }
});


document.getElementById('voice-input-btn').addEventListener('click', async () => {
  if (!isRecording) {
    isRecording = true;
    try {
      const startResponse = await fetch('http://localhost:5000/start_recording', { method: 'POST' });
      if (startResponse.ok) {
        const startData = await startResponse.json();
        displayMessage('log', 'Recording started.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('assistant', 'An error occurred. Please check the browser console.');
    }
  } else {
    isRecording = false;
    try {
      const stopResponse = await fetch('http://localhost:5000/stop_recording', { method: 'POST' });
      if (stopResponse.ok) {
        const stopData = await stopResponse.json();
        displayMessage('log', stopData.log);
        displayMessage('assistant', stopData.response);
        await displayGraphList();

        // Load the latest graph
        const graphResponse = await fetch('/api/graphs');
        if (graphResponse.ok) {
          const graphFiles = await graphResponse.json();
          if (graphFiles.length > 0) {
            const latestFile = graphFiles[0];
            Graph.jsonUrl(`graphs/${latestFile}`);
          }
        }
      } else {
        console.error('Error:', stopResponse.status);
        displayMessage('assistant', 'An error occurred. Please check the server logs.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('assistant', 'An error occurred. Please check the browser console.');
    }
  }
});

/////////////////////////TEXT INPUT/////////////////////


    const chatForm = document.getElementById('chat-form');
    const userInput = document.getElementById('user-input');
    const chatWindow = document.querySelector('.chat-window');


chatForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const message = userInput.value.trim();
  if (message !== '') {
    displayMessage('user', message);
    userInput.value = '';
    try {
      const response = await fetch('http://localhost:5000/process', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ message })
      });

      if (response.ok) {
        const data = await response.json();
        displayMessage('assistant', data.response);
        await displayGraphList();

        // Load the latest graph
        const graphResponse = await fetch('/api/graphs');
        if (graphResponse.ok) {
          const graphFiles = await graphResponse.json();
          if (graphFiles.length > 0) {
            const latestFile = graphFiles[0];
            Graph.jsonUrl(`graphs/${latestFile}`);
          }
        }
      } else {
        console.error('Error:', response.status);
        displayMessage('assistant', 'An error occurred. Please check the server logs.');
      }
    } catch (error) {
      console.error('Error:', error);
      displayMessage('assistant', 'An error occurred. Please check the browser console.');
    }
  }
});


    function displayMessage(sender, message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message';
      messageElement.innerHTML = `<strong>${sender}:</strong> ${message}`;
      chatWindow.appendChild(messageElement);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    // Call the displayGraphList function to populate the graph list
    displayGraphList();
  </script>
</body>
</html>
